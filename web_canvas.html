<html>
    <head></head>
    <body></body>
</html>

<style type="text/css">
    body{
        overflow-x: hidden;
        overflow-y: hidden;
        padding:0;
        border:0;
        margin:0;
    }

    img{
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
        opacity: 0.0;
        -webkit-user-drag: none;
    }

    canvas{
        z-index: 1;
    }
</style>

<script type="text/javascript">
    root_ele = document.getRootNode();
    html_ele = root_ele.children[0];
    body_ele = html_ele.children[1];
    canvas_ele = document.createElement("canvas");
    body_ele.appendChild(canvas_ele);
    ctx = canvas_ele.getContext("2d", {willReadFrequently: true});
    JavaScript_WaitToExecute_CodeArray = new Array();
    resize_task = false;
    lfdaot_render_fcount = 0;
    render_range_more = false;
    render_range_more_scale = 2.0;
    font_loaded = false;
    uploadFrame_addQueue = false;
    uploadFrame_finish = false;

    /*
    (if enable render_range_more)
    - this value will be change in python.
    - if call ctx.drawImage in python, this value most be true. because CanvasRenderingContext2D.prototype.drawImage function can`t auto change x, y, width, height.
    - if call ctx.???Image in python and this value is true, in python: can`t call ctx.translate and ctx.scale function. because if you do it, translate and scale will call twice. one in python, one in js.
    - if most call ctx.???Image and most call translate and scale in python, python can set this value to false, and at called function, set this value to true;
    */
    crc2d_enable_rrm = true;

    class RpeChartEffects {
        constructor(ctx) {
            this._ctx = ctx;
            this._offscreen_cv = document.createElement("canvas");
            this._offscreen_cv.width = this._ctx.canvas.width;
            this._offscreen_cv.height = this._ctx.canvas.height;
            this._offscreen_ctx = this._offscreen_cv.getContext("2d");
        }
        _clamp(v, s, e) {
            return v < s ? s : (v > e ? e : v)
        }
        _Coords2Index(x, y, width, height) {
            let nx = this._clamp(x, 0, width);
            let ny = this._clamp(y, 0, height);
            return (nx + ny * width) * 4;
        }

        Chromatic(dxr, dyr, dxg, dyg, dxb, dyb) {
            let width = this._ctx.canvas.width;
            let height = this._ctx.canvas.height;
            let imgData = this._ctx.getImageData(0, 0, width, height);
            let imgData2 = this._ctx.createImageData(width, height);
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    let idx = this._Coords2Index(x, y, width, height);
                    let ro = this._Coords2Index(x - dxr, y - dyr, width, height);
                    let go = this._Coords2Index(x - dxg, y - dyg, width, height);
                    let bo = this._Coords2Index(x - dxb, y - dyb, width, height);
                    imgData2.data[idx] = imgData.data[ro];
                    imgData2.data[idx + 1] = imgData.data[go + 1];
                    imgData2.data[idx + 2] = imgData.data[bo + 2];
                    imgData2.data[idx + 3] = 255;
                }
            }
            this._ctx.putImageData(imgData2, 0, 0);
        }

        CircleBlur() {

        }

        Fisheye() {

        }

        Glitch() {

        }

        Grayscale(factor) {
            this._ctx.save()
            this._ctx.filter = `grayscale(${factor * 100}%)`;
            this._ctx.drawImage(this._ctx.canvas, 0, 0);
            this._ctx.restore();
        }

        Noise() {

        }

        Pixel(size) {
            let width = this._ctx.canvas.width;
            let height = this._ctx.canvas.height;
            let pixsize = parseInt(size);
            let pixwidthnum = parseInt(width / pixsize);
            let pixheightnum = parseInt(height / pixsize);
            this._offscreen_cv.width = pixwidthnum;
            this._offscreen_cv.height = pixheightnum;
            this._offscreen_ctx.drawImage(this._ctx.canvas, 0, 0, pixwidthnum, pixheightnum);
            this._ctx.save()
            this._ctx.imageSmoothingEnabled = false;
            this._ctx.drawImage(this._offscreen_cv, 0, 0, width, height);
            this._ctx.restore();
        }

        RadialBlur(centerX, centerY, offset, sampleCount) {
            if (offset == 0.0) return;
            let width = this._ctx.canvas.width;
            let height = this._ctx.canvas.height;
            this._offscreen_cv.width = width;
            this._offscreen_cv.height = height;
            let imgData = this._ctx.getImageData(0, 0, width, height);
            this._offscreen_ctx.putImageData(imgData, 0, 0);
            
            for (let i = 0; i < sampleCount; i++) {
                let im_offset = offset * (i + 1) / sampleCount;
                let im_size_width = (1.0 + im_offset) * width;
                let im_size_height = (1.0 + im_offset) * height;
                let alpha = 1.0 - (i + 1) / sampleCount;
                this._ctx.save()
                this._ctx.globalAlpha = alpha;
                this._ctx.drawImage(
                    this._offscreen_cv,
                    centerX * width - im_size_width / 2,
                    centerY * height - im_size_height / 2,
                    im_size_width,
                    im_size_height
                )
                this._ctx.restore()
            }
        }

        Shockwave() {

        }

        Vignette() {

        }
    }

    class Queue {
        constructor() {this.items = []}
        put(element) {this.items.push(element)}
        get() {return this.items.shift()}
        empty() {return this.items.length === 0}
    }
    
    function resizeCanvas() {
        canvas_ele.width = window.innerWidth;
        canvas_ele.height = window.innerHeight;
        /*
        in python, width and height is the real size of canvas, so we donot need to scale the canvas.
        */
        // ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    function process_jswteca() {
        for(var i=0;i<JavaScript_WaitToExecute_CodeArray.length;i++){
            eval(JavaScript_WaitToExecute_CodeArray[i]);
        }
        JavaScript_WaitToExecute_CodeArray = new Array();
    }

    function hide_mouse() {
        body_ele.style.cursor = "none";
    }

    function change_color_block_opacity(opacity) {
        color_block_img_ele.style.opacity = opacity; // color_block_img_ele define in python code. 
    }

    function ease_out(x) {
        return Math.sqrt(1 - Math.pow(x - 1, 2));
    }

    function show_in_animation(first_call = true,start_time = 0.0) {
        if (!first_call){
            process = (new Date().getTime() / 1000 - start_time) / 1.25;
            ease_number = ease_out(process);
            if (process > 1.0) {
                change_color_block_opacity(1.0);
                return;
            }
            change_color_block_opacity(ease_number);
            setTimeout(() => show_in_animation(false,start_time),1000 / 60);
        }
        else{
            show_in_animation(false,new Date().getTime() / 1000);
        }
    }

    function show_out_animation(first_call = true,start_time = 0.0) {
        if (!first_call){
            process = (new Date().getTime() / 1000 - start_time) / 1.25;
            ease_number = ease_out(process);
            if (process > 1.0) {
                change_color_block_opacity(0.0);
                return;
            }
            change_color_block_opacity(1.0 - ease_number);
            setTimeout(() => show_out_animation(false,start_time),1000 / 60);
        }
        else{
            show_out_animation(false,new Date().getTime() / 1000);
        }
    }

    function loadFont(family,url) {
        var font = new FontFace(family, `url(${url})`);
        font.load().then(function(rfont) {
            document.fonts.add(rfont);
            font_loaded = true;
        })
    }

    async function async_sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function process_uploadFrame() {
        while (true) {
            await async_sleep(1000 / 60);
            if (! window.uploadFrame_Queue.empty()) {
                dataUrl = window.uploadFrame_Queue.get();
                pywebview.api.call_attr("uploadFrame",dataUrl);
            }
            else {
                if (uploadFrame_addQueue) {
                    uploadFrame_finish = true;
                }
            }
        }
    }

    function uploadFrame() {
        if (! window.uploadFrame_Queue) {
            window.uploadFrame_Queue = new Queue();
            process_uploadFrame();
        }

        dataUrl = canvas_ele.toDataURL("image/png");
        window.uploadFrame_Queue.put(dataUrl);
    }

    function PhigrosPlay_KeyEvent(callback) {
        return function (e) {
            if (event.isComposing || event.keyCode === 229) reutrn;
            callback(e);
        }
    }

    CanvasRenderingContext2D.prototype.drawRotateImage = function(im,x,y,width,height,deg,alpha) { // draw at the position center
        if (render_range_more && crc2d_enable_rrm) {x /= render_range_more_scale; y /= render_range_more_scale; width /= render_range_more_scale; height /= render_range_more_scale;}
        this.save();
        this.globalAlpha = alpha;
        if (!!deg){
            this.translate(x,y);
            this.rotate(deg * Math.PI / 180);
            this.drawImage(im,-width / 2,-height / 2,width,height);
        }
        else {
            this.drawImage(im,x - width / 2,y - height / 2,width,height);
        }
        this.restore();
    }

    CanvasRenderingContext2D.prototype.drawAnchorESRotateImage = function(im,x,y,width,height,deg,alpha) {
        if (render_range_more && crc2d_enable_rrm) {x /= render_range_more_scale; y /= render_range_more_scale; width /= render_range_more_scale; height /= render_range_more_scale;}
        this.save();
        this.globalAlpha = alpha;
        if (!!deg){
            this.translate(x,y);
            this.rotate(deg * Math.PI / 180);
            this.drawImage(im,-width / 2,-height,width,height);
        }
        else {
            this.drawImage(im,x - width / 2,y - height,width,height);
        }
        this.restore();
    }

    resizeCanvas();

    window.addEventListener("resize",function(){
        resizeCanvas();
    });

    rcf = new RpeChartEffects(ctx);
</script>